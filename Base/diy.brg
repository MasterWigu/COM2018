%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

extern FILE *outfp;
char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break labels */
/* label _L0 is a break without a while/switch) */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static void outstr(char *s) {
  while (*s) fprintf(outfp, pfCHAR, (unsigned char)*s++);
  fprintf(outfp, pfCHAR, 0);
}
static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}
#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);
static int doasm(Node *p) { return strcmp(LEFT_CHILD(LEFT_CHILD(p))->value.s, "asm") ? MAX_COST : 0 ; }
%}
%include "y.tab.h"
%term SC=';' COMMA=',' BLK='{' PMS='('
%term ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' GT='>' LT='<' EQ='=' OR='|' AND='&' FACT='!' 
%term ALLOC='#' INDEX='['
%%


list:	NIL
list:	SC(list, base)


base:	expr						1 { fprintf(outfp, pfTRASH, pfWORD); }

args:	NIL							{ p->place = 0; }
args:	VOID							{ p->place = 0; }
args:	COMMA(args, expr)			{ p->place =  ((LEFT_CHILD(p)->place) + 1); }


lvalue:	ID							1 { fprintf(outfp, pfADDR, p->value.s); }
lvalue: LOCAL						1 { fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4)); }
expr:	PTR(lvalue)					1 { fprintf(outfp, pfLOAD); }
expr:	REF(lvalue)	  				{ /* No code, but keep PTR to avoid missing LOADs */ }
lvec:	lvalue						1 { fprintf(outfp, pfLOAD); }
lvalue:	INDEX(lvec,expr) 			1 { fprintf(outfp, pfIMM pfMUL pfADD, pfWORD); }
lvalue:	PTR(lvalue)					1 { fprintf(outfp, pfLOAD); }
expr:	PTR(lvalue)					1 { fprintf(outfp, pfLOAD); }


expr:	ATR(expr,LOCAL)				1 { fprintf(outfp, pfDUP pfLOCA, RIGHT_CHILD(p)->value.i * (pfWORD/4)); }
expr:	ATR(expr,ID)				1 { fprintf(outfp, pfDUP pfADDRA, RIGHT_CHILD(p)->value.s); }
assign: expr						1 { fprintf(outfp, pfDUP); }
expr:	ATR(assign,lvalue)			1 { fprintf(outfp, pfSTORE); }
expr:	ID						1 { fprintf(outfp, pfADDRV, p->value.s); }
base:	ALLOC(alloc,lvalue)  			1 { fprintf(outfp, pfSTORE); }
alloc:	expr						1 { fprintf(outfp, pfIMM pfMUL pfALLOC pfSP, pfWORD); }



expr:	INT							1 { fprintf(outfp, pfIMM, p->value.i); }
expr:	REAL						1 { fprintf(outfp, pfIMM, p->value.i); }
expr:	STR 						1 { lbl++; fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(outfp, pfTEXT pfADDR, mklbl(lbl)); }
expr:	CALL(ID, args)				1 { fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)(pfWORD*(RIGHT_CHILD(p)->place))); }

expr:	ADD(expr,expr)				1 { fprintf(outfp, pfADD); }
expr:	SUB(expr,expr)				1 { fprintf(outfp, pfSUB); }
expr:	MUL(expr,expr)				1 { fprintf(outfp, pfMUL); }
expr:	DIV(expr,expr)				1 { fprintf(outfp, pfDIV); }
expr:	MOD(expr,expr)				1 { fprintf(outfp, pfMOD); }
expr:	OR(expr,expr)				1 { fprintf(outfp, pfOR); }
expr:	EQ(expr,expr)				1 { fprintf(outfp, pfEQ); }
expr:	NE(expr,expr)				1 { fprintf(outfp, pfNE); }
expr:	LT(expr,expr)				1 { fprintf(outfp, pfLT); }
expr:	LE(expr,expr)				1 { fprintf(outfp, pfLE); }
expr:	GT(expr,expr)				1 { fprintf(outfp, pfGT); }
expr:	GE(expr,expr)				1 { fprintf(outfp, pfGE); }
expr:	UMINUS(expr)				1 { fprintf(outfp, pfNEG); }
expr:	NOT(expr)					1 { fprintf(outfp, pfIMM pfEQ, 0); }
expr:	AND(and,expr)				1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and:	expr						1 { p->place = ++lbl; fprintf(outfp, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr:	OR(or,expr)					1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or: expr							1 { p->place = ++lbl; fprintf(outfp, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }



%! if-else
base:	ELSE(if,base)				1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
if:		IF(cond,base)				1 { p->place = ++lbl; fprintf(outfp, pfJMP pfLABEL, mklbl(p->place), mklbl(LEFT_CHILD(p)->place)); }
%! simple if (no else): uses only one label
base:	IF(cond,base)				1 { fprintf(outfp, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
cond:	expr						1 { p->place = ++lbl; fprintf(outfp, pfJZ, mklbl(p->place)); }





expr:	INCR(lvalue)					1 { fprintf(outfp, pfDUP pfINCR pfLOAD, 1); }
expr:	DECR(lvalue)					1 { fprintf(outfp, pfDUP pfDECR pfLOAD, 1); }
expr:	POSINC(lvalue)				1 { fprintf(outfp, pfDUP pfLOAD pfSWAP pfINCR, 1); }
expr:	POSDEC(lvalue)				1 { fprintf(outfp, pfDUP pfLOAD pfSWAP pfDECR, 1); }




%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;


void externs() {
	int i;

	for (i = 0; i < extcnt; i++)
		if (extrns[i])
			fprintf(outfp, pfEXTRN, extrns[i]);
}


/*void declare(int pub, int cnst, Node *type, char *name, Node *value)*/
void variable(char *name, Node *type, Node *init, int cnst) {
	int i = 0, siz = 1;
	if (cnst)
		fprintf(outfp, pfRODATA pfALIGN pfLABEL pfGLOBL, name, name, pfOBJ);
	else
		fprintf(outfp, pfDATA pfALIGN pfLABEL pfGLOBL, name, name, pfOBJ);


	if (init) {
		printf("AAAAAAAAAAA %d\n", init->info);
		switch (init->info) {
			case 1: 
				fprintf(outfp, pfINTEGER, init->value.i);
				break;
			case 3: 
				fprintf(outfp, pfDOUBLE, init->value.r);
				break;
			case 2: { 
				char *l = mklbl(++lbl);
				fprintf(outfp, pfID, l);
				fprintf(outfp, pfDATA pfALIGN pfLABEL, l);
				outstr(init->value.s);
				break;
			} 
			case 7: { 
				char *l = mklbl(++lbl);
				fprintf(outfp, pfID, l);
				fprintf(outfp, pfRODATA pfALIGN pfLABEL, l);
				outstr(init->value.s);
				break;
			}
			default:
				fprintf(outfp, pfID, init->value.s);
				break;
		}   
	}
	else {
		printf("BBBBBBBBB\n");
		switch (type->value.i) {
			case 1: 
				fprintf(outfp, pfINTEGER, 0);
				break;
			case 2: 
				fprintf(outfp, pfINTEGER, 0); /*aka null pointer to string*/
				break;
			case 3:
				fprintf(outfp, pfDOUBLE, 0.0);
				break;
			default: /*only occurs when value.i > 10, aka pointers*/
				fprintf(outfp, pfINTEGER, 0); /*aka null pointer to string*/
				break;
		} 
	}

	for (i = 0; i < extcnt; i++)
		if (init && extrns[i] && strcmp(extrns[i], name) == 0) extrns[i] = 0;
}


void function(char *name, int enter, Node *body, int tVoid) {
	if (body->attrib == NIL) {
		extrns[extcnt++] = dupstr(mkfunc(name));
		return;
	}

	Node *stmt = LEFT_CHILD(body);

	int i;
	extern int errors, trace;
	extern char **yynames;
	if (errors) return;
	if (trace) printNode(stmt, 0, yynames);
	fflush(stdout);
	fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
	yyselect(stmt);
	if (!tVoid)
		fprintf(outfp, pfLOCV pfPOP pfLEAVE pfRET, -4);
	else
		fprintf(outfp, pfPOP pfLEAVE pfRET);
	/*fprintf(outfp, pfLEAVE pfRET); /* just in case ... */
	freeNode(stmt);
	for (i = 0; i < extcnt; i++) {
		if (stmt->attrib != NIL && extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;
	}
}





#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost) {
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	fprintf(stderr, "0x%lx:%s matched %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		extern char **yynames;
		fprintf(stderr, "0x%lx:%s NO MATCH %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
		printNode(p, 0, yynames);
	}
}
#endif

