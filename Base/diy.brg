%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"

extern FILE *outfp;
char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break labels */
/* label _L0 is a break without a while/switch) */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static void outstr(char *s) {
  while (*s) fprintf(outfp, pfCHAR, (unsigned char)*s++);
  fprintf(outfp, pfCHAR, 0);
}
static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}
#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);
static int doasm(Node *p) { return strcmp(LEFT_CHILD(LEFT_CHILD(p))->value.s, "asm") ? MAX_COST : 0 ; }
%}
%include "y.tab.h"
%term SC=';' COMMA=',' BLK='{' PMS='('
%%


%!finit:	PMS(bloco, params)		1 {printf("TEST %d\n", 1);}



blocop:	NIL
blocop: bloco


bloco:	BLK(list, decls)


decls:	NIL
decls:	SC(decls, base)			1 {printf("TEST %d\n", 3);}
decls:	SC(decls, param)			1 {printf("TEST %d\n", 3);}

%!params:	param 					1 {printf("TEST %d\n", 4);}
%!params:	COMMA(params, param)	1 {printf("TEST %d\n", 5);}

param:	PARAM(INT, ID)				1 {printf("TEST %d\n", 6);}


base:	expr						1 { fprintf(outfp, pfTRASH, pfWORD); }


list:	NIL
list:	SC(list, base)



args:	NIL							{ p->place = 0; }
args:	COMMA(args, expr)			{ p->place =  ((LEFT_CHILD(p)->place) + 1); }


lvalue:	ID							1 { fprintf(outfp, pfADDR, p->value.s); }
lvalue: LOCAL						1 { fprintf(outfp, pfLOCAL, p->value.i * (pfWORD/4)); }

expr:	ATR(expr,LOCAL)				1 { fprintf(outfp, pfDUP pfLOCA, RIGHT_CHILD(p)->value.i * (pfWORD/4)); }
expr:	ATR(expr,ID)				1 { fprintf(outfp, pfDUP pfADDRA, RIGHT_CHILD(p)->value.s); }
assign: expr						1 { fprintf(outfp, pfDUP); }
expr:	ATR(assign,lvalue)			1 { fprintf(outfp, pfSTORE); }

expr:	INT							1 { fprintf(outfp, pfIMM, p->value.i); }
expr:	STR 						1 { lbl++; fprintf(outfp, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(outfp, pfTEXT pfADDR, mklbl(lbl)); }
expr:	CALL(ID, args)			1 { fprintf(outfp, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)(pfWORD*(RIGHT_CHILD(p)->place))); }








%%
#include "y.tab.h"
extern void yyerror(const char*);
extern char **yynames;
extern int trace;


void externs() {
	int i;

	for (i = 0; i < extcnt; i++)
		if (extrns[i])
			fprintf(outfp, pfEXTRN, extrns[i]);
}

/*
void declare(int pub, int cnst, Node *type, char *name, Node *value)
void variable(int pub, int cnst, Node *type, char *name, Node *init) {
  int i = 0, siz = 1;
  fprintf(outfp, pfGLOBL pfDATA pfALIGN pfLABEL, name, pfOBJ, name);
  if (vc->type == nodeInt) siz = vc->value.i;
  if (vc->attrib == LOCAL) {
    lbl++;
    fprintf(outfp, pfID pfLABEL, mklbl(lbl), mklbl(lbl));
  }
  if (init) {
    for (i = 0; i < init->value.sub.num; i++)
      switch (init->CHILD(i)->attrib) {
        case INT: 
        	fprintf(outfp, pfWORD == 4 ? pfINTEGER : pfLONG, init->CHILD(i)->value.i);
        	break;
		case NAME:
			fprintf(outfp, pfID, init->CHILD(i)->value.s);
			break;
		case STRING: { 
			char *l = mklbl(++lbl);
			fprintf(outfp, pfRODATA pfALIGN pfLABEL, l);
			outstr(init->CHILD(i)->value.s);
			fprintf(outfp, pfDATA pfID, l);
			break;
		}  
    }
    if (i < siz)  fprintf(outfp, pfBYTE, pfWORD * (siz - i));
  }
  else fprintf(outfp, pfBYTE, pfWORD * siz);
  for (i = 0; i < extcnt; i++)
    if (extrns[i] && strcmp(extrns[i], name) == 0) extrns[i] = 0;
}

*/
void function(char *name, int enter, Node *stmt, int tVoid) {
	if (stmt->attrib == NIL) {
		extrns[extcnt++] = dupstr(mkfunc(name));
		return;
	}
	int i;
	extern int errors, trace;
	extern char **yynames;
	if (errors) return;
	if (trace) printNode(stmt, 0, yynames);
	fflush(stdout);
	fprintf(outfp, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
	yyselect(stmt);
	if (tVoid)
		fprintf(outfp, pfLOCV pfPOP pfLEAVE pfRET, -4);
	else
		fprintf(outfp, pfPOP pfLEAVE pfRET);
	/*fprintf(outfp, pfLEAVE pfRET); /* just in case ... */
	freeNode(stmt);
	for (i = 0; i < extcnt; i++) {
    	if (stmt->attrib != NIL && extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;
	}
}





#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost) {
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	fprintf(stderr, "0x%lx:%s matched %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
	  extern char **yynames;
	  fprintf(stderr, "0x%lx:%s NO MATCH %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	  printNode(p, 0, yynames);
	}
}
#endif

